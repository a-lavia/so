\section{Ejercicio 7}

\subsection{Enunciado}
En base a lo anterior, defina dos nuevos algoritmos de scheduling. Ambos del tipo \textit{shortest job first}. Para ambos puede considerar que solamente correran tareas de tipo TaskCPU.

\begin{enumerate}[a)]
\item Uno no reentrante. Tomará como parámetros la cantidad de procesadores y el tiempo total de ejecución de cada tarea en el lote. Ejecutará la tarea que menos tiempo de cpu necesite. Al terminar de ejecutarla, volverá a elegir la de menor tiempo de ejecución.
Será llamado \textbf{SJF}.

\item Uno reentrante. Tomará como parámetros la cantidad de procesadores, los \textbf{Quantums} de cada uno de ellos y el tiempo total de ejecución de cada tarea en el lote. Un proceso correrá en ese procesador durante ese quantum. Al terminar dicho tiempo, ejecutará la tarea a la que menos tiempo le quede de ejecución (podría seguir ejecutando la tarea actual). Existe una única cola de procesos para todos los procesadores. Lo llamaremos
\textbf{RSJF}.
\end{enumerate}

\subsection{Resolución}

Para este ejercicio se pedía realizar las implementaciones de dos nuevos algoritmos de scheduling, del tipo \emph{shortest job first}, que sólo corren tareas del tipo TaskCPU.
La primera de ellas, llamada \textbf{SJF}, elige y ejecuta siempre la tarea con el menor tiempo de CPU que necesite hasta terminar.
La segunda, llamada \textbf{RSJF}, también elige y ejectua la tarea con el menor tiempo de CPU que necesite pero, cada core posée un quantum por lo que cuando se termina éste, se toma una nueva tarea con el menor tiempo de CPU, se encola la tarea desalojada y luego se reinicia el quantum del core.

\subsection{Implementación \textbf{SJF}}

Esta implementación toma como parametros la cantidad de cores y los tiempos de cada proceso a ser ejecutado en el orden en que se los carga.

Para facilitar el manejo de los procesos con sus respectivos tiempos, generamos un struct llamada \emph{Proceso} que tiene como estructura el pid del proceso y su tiempo de ejecución. También posée el operador $<$ que sirve para comparar los tiempos de los procesos.

Con esto, el scheduler posée como estructra dos colas:

\begin{itemize}

\item \emph{tiempos\_procesos}: una cola normal que se utiliza para encolar los tiempos de los procesos que recibe como parametro este scheduler.

\item \emph{cola\_procesos}: esta es una cola de prioridad de la estructura Proceso, donde la máxima prioridad la tiene el proceso con menor tiempo de ejecución.

\end{itemize}

El constructor de este scheduler simplemente encola los tiempos de los procesos en la cola \emph{tiempos\_procesos}.

La función \textbf{load} crea un nuevo Proceso con el pid que recibe como parametro y el primer elemento de la cola (ya que ésta tiene los tiempos de los elementos en el orden que van llegando) y encolo este Proceso en la cola de prioridad \emph{cola\_procesos}.

La función \textbf{unblock} no se utiliza ya que, por enunciado, este scheduler sólo corre tareas del tipo TaskCPU (que no tiene llamadas bloqueantes).

La función \textbf{tick} en este scheduler es muy sencilla, pasamos a mostrar un pseudocódigo que muestre su comportamiento:

\begin{algorithmic}
\Function{int tick}{int cpu, const enum Motivo m}

	\If {\emph{(Si la tarea actual es la IDLE\_TASK o el motivo es que terminó el proceso actual) y la cola de prioridad \textbf{cola\_procesos} no está vacía}}
		\State Desencolo de \textbf{cola\_procesos} el primero elemento (o sea, el que tiene el menor tiempo) y lo devuelvo.
	
	\ElsIf{\emph{Si el motivo es que pasó un tick de reloj}}
		\State Devuelvo el proceso actual.

	\Else
		\State Devuelvo IDLE\_TASK.
	\EndIf
\EndFunction	
\end{algorithmic}


\subsection{Implementación \textbf{RSJF}}


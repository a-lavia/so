\section{Introducción}
En este informe presentaremos los algoritmos realizados para la implementación de una \textbf{DHT Kademlia} simplificada, para ello utilizamos la interfaz \textbf{MPI} que nos servirá para pasar mensajes a través de los nodos que componen nuestra red.

\section{Ejercicio 1}
Para las implementaciones de \emph{\_\_find\_nodes}, \emph{\_\_find\_nodes\_join} \emph{\_\_handle\_console\_store} y \emph{\_\_handle\_console\_look\_up} preguntamos a los nodos mínimos por el hash utilizando las funciones \textbf{MPI.COMM\_WORLD.send()} y recibimos la respuesta con \textbf{MPI.COMM\_WORLD.recv()}. Estas funciones de MPI son bloqueantes, las implementaciones son las siguientes.

\subsection{Función \_\_find\_nodes}
La función \emph{\_\_find\_nodes} funciona de la siguiente forma: como tiene que buscar los nodos más cercanos al hash que me pasan como parametro, buscamos los más cercanos. Les enviamos un mensaje de forma bloqueante con la función \textbf{MPI.COMM\_WORLD.send()} a los nodos más cercanos al hash del nodo contacto y estos a su vez realizan lo mismo con sus nodos más cercanos hasta haber procesado todos los nodos y cada uno devuelve sus nodos más cercanos al hash. Luego de enviar cada mensaje, esperamos de forma bloqueante su respuesta con \textbf{MPI.COMM\_WORLD.recv()}, esto le da un orden al recorrido del filesystem distrubuído.

Una vez que se procesaron todos los nodos y obtuvimos los más cercanos al hash los devuelvemos.


\subsection{Función \_\_find\_nodes\_join}
La función \emph{\_\_find\_nodes\_join} funciona de una forma similar a \emph{\_\_find\_nodes} con la diferencia que en vez de buscar los nodos más cercanos de un hash que me pasan como parametro, busco los más cercanos al nodo que esta haciendo el join. Las funciones \textbf{MPI.COMM\_WORLD.send()} y \textbf{MPI.COMM\_WORLD.recv()} las utilizamos de la misma manera, pero \textbf{MPI.COMM\_WORLD.recv()} no devuelve sólo los hash y rank de cada nodo cercano sino también sus archivos que el nodo que hace el join debe agregar a su base porque son migrados de los nodos más cercanos hacia él y porque este es el nuevo más cercano a esos archivos.

\subsection{Función \_\_handle\_console\_store}
El procedimiento de ésta función es muy simple. Como lo que tiene que hacer es guardar un archivo en la red, se realiza lo siguiente: guardamos el archivo en el nodo (rank) que se pasa como parametro. Luego, obtenemos sus mínimos locales del nodo al hash del archivo y con estos llamamos a la funcion \emph{\_\_find\_nodes} para obtener todos los nodos mas cercanos al hash del archivo. Con los nodos mas cercanos obtenemos los de menor distancia al hash del archivo con la función \emph{\_\_get\_mins}. Por último, enviamos el archivo a todos estos nodos de forma bloqueante, con la función \textbf{MPI.COMM\_WORLD.send()} para que ellos también lo guarden.


\subsection{Función \_\_handle\_console\_look\_up}
Esta función debe buscar un archivo en la red. Lo que hacemos es lo siguiente: obtenemos los mínimos locales del nodo (rank) que se pasa como parámetro al hash del archivo. Con éstos llamamos a la función \emph{\_\_find\_nodes} para obtener los nodos más cercanos al hash del archivo. Luego, lo que hacemos en enviarles a los nodos más cercanos el hash del archivo preguntandoles si lo tienen por la función bloqueante \textbf{MPI.COMM\_WORLD.send()} y esperamos la respuesta también de forma bloqueante por \textbf{MPI.COMM\_WORLD.recv()}. Si lo tienen envian los datos, sino devuelven false. En el caso de que se encuentre el nodo que que está realizando el look up dentro de los más cercanos, no se le envía un mensaje sino que se busca si está el archivo en él directamente.

Por último, se envia de forma bloqueante al nodo consola si está el archivo o no.

\section{Ejercicio 3}
Para la implementación no bloqueante de \emph{\_\_find\_nodes} y  \emph{\_\_find\_nodes\_join} reemplazamos la funcion \\ \textbf{MPI.COMM\_WORLD.send()} por la versión no bloqueante de la misma \textbf{MPI.COMM\_WORLD.isend()}, donde esta retorna de inmediato sin bloquearse. Lo que primero realizamos es enviar todos los mensajes y luego esperamos de forma bloqueante con la función \textbf{MPI.COMM\_WORLD.recv()} a que vayan llegando las respuestas.

\subsection{Función \_\_find\_nodes}
Esta función tiene un comportamiento similar a la del ejercicio anterior salvo por los siguientes cambios: en vez de ir enviando pedidos de forma bloqueante a cada nodo para obtener los más cercanos al hash, envío los pedidos a todos los nodos que tengo encolados de forma no bloqueante con la función \textbf{MPI.COMM\_WORLD.isend()}. Una vez que se vació la cola, esperamos de forma bloqueante las respuestas del primero que me responda, no de algún nodo en particular. Una vez que responde alguno el procedimiento es el mismo, se van encolando los nodos más cercanos que envían como respuesta y nuevamente se les envía los pedidos a todos de forma no bloqueante. Para saber si obtuvimos todas las respuestas llevamos un contador que aumenta cada vez que se realiza un pedido y disminuye cada vez que se recibe alguna respuesta. Por último, una vez que se procesaron todos los nodos y obtuve los más cercanos los devolvemos.

\subsection{Función \_\_find\_nodes\_join}
Esta función tiene los mismos cambios que la anterior.

